{"title":"Les fondamentaux de Python","markdown":{"yaml":{"title":"Les fondamentaux de Python"},"headingText":"1. Introduction aux variables et types de Données","containsRefs":false,"markdown":"\nBienvenue dans ce cours introductif sur Python. \nCe cours couvrira les concepts de base pour vous permettre de démarrer avec Python.\n\n\n## 1.1 Variables\n\nLes variables sont essentielles en programmation. Elles servent de conteneurs pour stocker des données, comme des nombres ou des textes. En Python, créer une variable est simple :\n\n\n```{.python}\nx = 10\n```\n\nIci, x est une variable contenant la valeur 10. Python est un langage à typage dynamique, ce qui signifie que vous n'avez pas besoin de déclarer le type de la variable explicitement.\n\n\nIci, x est une variable contenant la valeur 10. Python est un langage à typage dynamique, ce qui signifie que vous n'avez pas besoin de déclarer le type de la variable explicitement.\n\n\nAffectation : L'opérateur = est utilisé pour assigner une valeur à une variable.\n\n\nTypage dynamique : Python détermine le type de la variable lors de son exécution.\n\n\nRéaffectation : Les valeurs des variables peuvent être modifiées.\n\n\nSensibilité à la casse : a et A sont considérées comme deux variables distinctes.\n\n\nAstuce : Utilisez print(variable1, variable2) pour afficher plusieurs variables.\n\n\nConventions de Nommage\n\nLes conventions courantes incluent :\n\ncamelCase : maVariable\nPascalCase : MaVariable\nsnake_case : ma_variable\nÉvitez les noms de variables commençant par des chiffres, ou contenant des espaces ou des symboles spéciaux.\n\n## 1.2 Types de données\n\nPython offre une variété de types de données :\n\nEntiers (int) : Nombres sans décimales (5, -3).\n\nFlottants (float) : Nombres avec décimales (3.14).\n\nChaînes de caractères (str) : Textes (\"Bonjour\").\n\nBooléens (bool) : Valeurs True ou False.\n\n# 2. Conversion de types et opérations\n\n## 2.1 Convertir des types pour la programmation\nLe processus de conversion de type, également appelé \"casting\", permet de changer une valeur d'un type de données à un autre.\n\n\nLes fonctions intégrées de Python incluent les entiers (int), les chaînes de caractères (str), les booléens (bool) et les nombres à virgule flottante (float).\n\nObservons quelques exemples de conversion entre ces catégories :\n\n### Conversion d'une valeur en entier (`int`)\n\n```{.python}\n# Depuis une chaîne de caractères** :\nchaine = \"789\"\nnombre = int(chaine)  # Convertit la chaîne \"789\" en entier 789\n\n## Depuis un booléen** :\nvrai = True\nentier = int(vrai)  # Convertit True en 1\n\n## Depuis un float** :\nflottant = 7.36\nentier = int(flottant)  # Convertit 7.36 en 7 (troncature, pas d'arrondi)\n```\n### Conversion d'une valeur en Chaîne de Caractères (`str`)\n\n```{.python}\n## Depuis un entier ou un float** :\nnombre = 789\nchaine = str(nombre)  # Convertit l'entier 789 en chaîne \"789\"\n\n## Depuis un booléen** :\nvrai = True\nchaine = str(vrai)  # Convertit True en \"True\"\n```\n### Conversion d'une valeur en Booléen (`bool`)\n\n```{.python}\n## Depuis une chaîne de caractères** :\nchaine = \"\"\nbooleen = bool(chaine)  # Convertit une chaîne vide en False\nchaine2 = \"Python\"\nbooleen2 = bool(chaine2)  # Convertit \"Python\" en True\n\n## Depuis un nombre** : \nnombre = 0\nbooleen = bool(nombre)  # Convertit 0 en False\nnombre2 = 123\nbooleen2 = bool(nombre2)  # Convertit 123 en True\n```\n\n### Conversion d'une valeur en Float (`float`)\n\n```{.python}\n## Depuis une chaîne de caractères** :\nchaine = \"673.85\"\nflottant = float(chaine)  # Convertit la chaîne \"673.85\" en float 673.85\n\n## Depuis un entier** :\nentier = 500\nflottant = float(entier)  # Convertit l'entier 500 en float 500.0\n\n## Depuis un booléen** :\nvrai = True\nflottant = float(vrai)  # Convertit True en 1.0\n```\n\n### Affectation de valeurs différentes\n\n```{.python}\nx, y, z = \"Chocolat\", \"Spéculos\", \"Café\"\nprint(x)\nprint(y)\nprint(z)\n```\nAffectation de la même valeur\n\n```{.python}\nx = y = z = \"Café\"\nprint(x)\nprint(y)\nprint(z)\n```\n## 2.2 Opérations\n\n### Opérations arithmétiques\n\nArithmétique : Addition (+), soustraction (-), multiplication (*), et division (/).\n\n```{.python}\nsomme = 20 + 15      # Résultat: 35\ndifference = 20 - 5  # Résultat: 15\nproduit = 20 * 5     # Résultat: 100\nquotient = 40 / 5    # Résultat: 8.0\n```\n\nModulo (%) retourne le reste de la division \nPuissance (**) élève un nombre à une certaine puissance.\n\n```{.python}\nreste = 10 % 3       # Résultat: 1\npuissance = 2 ** 3   # Résultat: 8\n```\n### Opérations sur les chaînes \n\nLa concaténation (+) combine des chaînes\n\nLa répétition (*) répète une chaîne un certain nombre de fois.\n\n```{.python}\nmessage = \"Salut\" + \"bande de nazes\"  # Résultat: \"Salut bande de nazes\"\necho = \"Ho\" * 3                    # Résultat: \"HoHoHo\"\n```\n\n### Opérateurs d'affectation composés\n\nLes raccourcis appelés opérateurs d'affectation composés combinent une affectation et une opération arithmétique ou binaire.\n\nEn somme, ils vous permettent d'effectuer une opération sur une variable et de réaffecter le résultat en une seule étape.\n\n```{.python}\n# Initialisation de x\nx = 5\nprint(x)\n\n# Ajouter et assigner\nx += 2  # x est maintenant 7\nprint(x)\n\n# Soustraire et assigner\nx -= 3  # x est maintenant 4\nprint(x)\n\n# Multiplier et assigner\nx *= 4  # x est maintenant 16\nprint(x)\n\n# Diviser et assigner\nx /= 2  # x est maintenant 8\nprint(x)\n\n# Division entière et assigner\nx //= 3  # x est maintenant 2\nprint(x)\n\n# Modulo et assigner\nx %= 3  # x est maintenant 2\nprint(x)\n\n# Exponentielle et assigner\nx **= 2  # x est maintenant 4\nprint(x)\n```\n# 3. Commentaires et affichage\n\n## 3.1 Commentaires\n\nLe code est expliqué à l'aide de commentaires.\n\nIls sont extrêmement utiles pour ceux qui lisent votre code, ainsi que pour vous-même. Les commentaires commencent par un **#** et se poursuivent jusqu'à la fin de la ligne.\n\nLors de l'exécution du code, les commentaires sont ignorés.\n\n```{.python}\n# Ceci est un commentaire \n\nz = 69  # Ceci est un commentaire suivant une instruction\n\n# Vous pouvez utiliser les commentaires pour expliquer\n# ce que votre code est censé faire :\nz = x + 9  # Ajout de 9 à x et stockage du résultat dans z\n```\n\n## 3.2 Affichage\n\nLa fonction print() est utilisée pour l'affichage.\n\nElle permet d'afficher sur la console le texte, les nombres et d'autres objets.\n\n```{.python}\nprint(\"Salut, ça va ?\")  # Affiche un message simple\n\nnombre = 69\nprint(nombre)  # Affiche la valeur de la variable 'nombre'\n\n# Vous pouvez aussi combiner du texte et des variables :\nprint(\"Le nombre est\", nombre)  # Affiche \"Le nombre est 69\"\n```\n### Utilisation de f-string\n\n```{.python}\nprenom = 'Maroua'\nage = 30\ntaille = 155\n\n# Formatage de chaînes avec f-string pour une lisibilité améliorée :\nprint(f\"Le nombre est {nombre}\") \nprint(f\"{prenom}, est partie\")\n```\n### f-string avec Plusieurs Variables\n\n```{.python}\nprint(f\"{prenom} mesure {taille} metres et a {age} ans\")\n```\n\n### Utilisation de format\n\n```{.python}\nprint(\"{} a {} ans \".format(prenom, age))\n```\n\n- Les variables sont insérées dans la chaîne de caractères à l'aide de la méthode.format().\nLes espaces réservés appelés \"{}\" seront remplacés par les arguments de la fonction \".format()\" dans l'ordre.\nLe premier \"{}\" contient l'insertion de \"ma_chaine\" et de \"age\", respectivement.\n\n Calculer et mesurer\n\nLa valeur de \"prop\" est affichée dans le premier \"print(prop)\", avec tous ses chiffres après la virgule.\n- La seconde fonction \"print()\" utilise une string f avec un format spécifique appelé \"{prop:.2f}\". \n\nEn conséquence, la valeur \"prop\" affichera seulement deux chiffres après la virgule.\n\n```{.python}\nprop = (4500 + 2575) / 14800\nprint(prop)\nprint(f\"La proportion de GC est {prop:.2f}\")\n```\n# 4. Structures de contrôle\n\n## 4.1 Les opérateurs\n\nLes opérateurs Python sont utilisés pour effectuer des opérations sur les variables et les valeurs.\n\n**Les opérateurs de comparaison** incluent égal à, différent de, supérieur à, inférieur à, supérieur ou égal à, et inférieur ou égal à.\n\n| Opérateur comparaison | Description |\n| ----------- | ----------- |\n| Egalité | == |\n| Différent de |!= |\n| Supérieur | > |\n| Inférieur | < |\n| Supérieur ou égale | >= |\n| Inférieur ou égale | <= |\n\n\n - Renvoient soit Vrai, soit Faux, en fonction du résultat de la comparaison.\n\n**Les opérateurs logiques** et, ou et non sont souvent combinés avec les opérateurs de comparaison.\n\n| Opérateur logique| Description | Résultat |\n| ----------- | ----------- |----------- |\n| And | and | True si les deux propositions sont vraies|\n| Or |  or | True si au moins une des propositions est Vraie |\n| Not | not | inverse de l'instruction |\n\n\n**Les opérateurs d'appartenance** in et not in sont utilisés pour vérifier si une valeur ou une chaîne de caractères se trouve à l'intérieur d'une autre valeur, chaîne de caractères ou séquence.\n\n| Opérateur logique| Description | Résultat |\n| ----------- | ----------- |----------- |\n| In | in | True si la valeur spécifiée est présente dans l'objet.|\n| Not in | not in | True si la valeur spécifiée n'est pas présente dans l'objet.|\n\n\n```{.python}\n# Exemples d'opérateurs de comparaison\nprint(\"Opérateurs de comparaison:\")\nprint(5 == 5)  # Égalité, renvoie True\n\nprint(5 != 2)  # Différent de, renvoie True\nprint(5 > 3)   # Supérieur à, renvoie True\nprint(5 < 8)   # Inférieur à, renvoie True\nprint(5 >= 3)  # Supérieur ou égal à, renvoie True\nprint(5 <= 8)  # Inférieur ou égal à, renvoie True\n\n# Exemples d'opérateurs logiques\nprint(\"\\nOpérateurs logiques:\")\nprint(True and False)  # and, renvoie False\nprint(True or False)   # or, renvoie True\nprint(not True)        # not, renvoie False\n\n# Exemples d'opérateurs d'appartenance\nprint(\"\\nOpérateurs d'appartenance:\")\nliste = [1, 2, 3, 4, 5]\nprint(3 in liste)       # in, renvoie True\nprint(6 not in liste)   # not in, renvoie True\n```\n\n## 4.2 Conditions\n\n```{.python}\n# condition\nx = 100 \n\n# Première condition : vérifie si x est inférieur à 10\nif x < 10:\n    print(\"x est inférieur à 10\")\n# Deuxième condition : vérifie si x est supérieur ou égal à 100\nelif x >= 100:\n    print(\"x est supérieur ou égal à 100\")\n# Dernière condition : si toutes les conditions précédentes sont fausses\nelse:\n    print(\"x est supérieur à 10 mais inférieur à 100\")\n```\n\n\n```{.python}\n# Initialisation des variables\nx = 100 \ny = 30 \n\n# Première condition : vérifie si x est inférieur à 10 ET y est supérieur à 20\nif (x < 10) and (y > 20):\n    print(\"x est inférieur à 10 et y est supérieur à 20\")\n# Deuxième condition : vérifie si x est supérieur ou égal à 100 OU y est supérieur ou égal à 30\nelif x >= 100 or y >= 30:\n    print(\"x est supérieur ou égal à 100 ou y est supérieur ou égal à 30\")\n# Dernière condition : si toutes les conditions précédentes sont fausses\nelse:\n    print(\"x est supérieur à 10\")\n```\n## 4.3 Les boucles \n\n### Boucle for\n\nLa boucle for peut être utilisée pour parcourir différentes structures de données, telles qu'une liste, un tuple, un tableau, une chaîne de caractères ou un dictionnaire.\n\nLa boucle commence par examiner le premier élément de la séquence et effectuer des actions dans son corps avant de passer à l'élément suivant jusqu'à ce que la séquence soit terminée.\n\n Une boucle est composée d'un mot-clé appelé \"for\", d'une variable temporaire qui contient chaque élément, d'un mot-clé appelé \"in\" et de la séquence à parcourir, suivie de deux points. Jusqu'au bout de l'élément - Appliquer des opérations sur la variable temporaire du corps de la boucle pour effectuer diverses opérations.\n- Combiner des fors - La méthode \"items()\" permet de boucler les clés et les valeurs dans les dictionnaires.\n\n```{.python}\n# Exemple de boucle for\nfor i in range(5):\n    print(i)\n\nfruits = [\"pomme\", \"banane\", \"mangue\", \"cerise\"]\nfor fruit in fruits:\n    print(fruit)\n\nprint(\"Boucle for sur une liste:\")\nma_liste = [1, 2, 3, 4, 5]\nfor element in ma_liste:\n    print(element)\n\nnombres = [1, 2, 3, 4, 5]\nfor nombre in nombres:\n    if nombre % 2 == 0:\n        print(f\"{nombre} est pair\")\n    else:\n        print(f\"{nombre} est impair\")\n```\n\n### Boucle while\n\nTant qu'une condition est vraie, la boucle while itère sur un bloc de code.\nLes boucles \"while\" continuent l'itération tant que la condition reste vraie, contrairement aux boucles \"for\".\n\n- \"break\" pour interrompre une boucle \"while\" prématurément, même si la condition est toujours vraie.\nUne boucle \"while\" peut utiliser \"else\" pour indiquer un bloc de code qui s'exécutera lorsque la condition de la boucle ne sera plus vraie.\nIl est possible d'ignorer le code restant dans l'itération actuelle de la boucle en cliquant sur \"continue\" pour passer à l'itération suivante.\n- Afin d'éviter de créer des boucles infinies, utilisez \"continue\" avec précaution.\n\n```{.python}\n# Boucle while avec break\nprint(\"\\nBoucle while avec break:\")\ni = 1\nwhile i <= 5:\n    print(i)\n    if i == 3:\n        print(\"Break à 3\")\n        break\n    i += 1\n\n# Boucle while avec continue\nprint(\"\\nBoucle while avec continue:\")\ni = 0\nwhile i < 5:\n    i += 1\n    if i == 3:\n        continue\n    print(i)\n\n# Boucle while avec else\nprint(\"\\nBoucle while avec else:\")\ni = 1\nwhile i <= 5:\n    print(i)\n    i += 1\nelse:\n    print(\"La condition n'est plus vraie (i > 5)\")\n\n# Exemple de boucle while True\nprint(\"Boucle while True avec un mécanisme de sortie :\")\n\ncompteur = 0\nwhile True:\n    compteur += 1\n    print(compteur)\n\n    # Interrompre la boucle si compteur atteint 5\n    if compteur == 5:\n        print(\"Compteur a atteint 5, sortir de la boucle.\")\n        break\n```\n\n# 5. Structures séquentielles\n\nChaque structure séquentielle a ses propres caractéristiques et utilisations, offrant une grande flexibilité pour le traitement des données. Les dictionnaires et les listes sont très populaires pour leur flexibilité et leur capacité de stockage dynamique.\n\n\nLes chaînes de caractères (strings) sont utilisées pour stocker et modifier du texte. Le texte est entouré de guillemets simples (\"...\"), doubles (\"...\"\") ou triples (\"...\") pour les chaînes de plusieurs lignes.\n\n\n  - Séquences de caractères avec un index de 0.\n  Les limites peuvent être marquées par des guillemets simples, doubles ou triples.\n  - Par exemple, \"Python\" et \"Data\".\n  Caractères d'échappement : Utilisez des caractères d'échappement (\"\") pour inclure des caractères spéciaux, tels que des guillemets ou des retours à la ligne, dans une chaîne.\n\n  ```{.python}\n  python\n  citation = \"Elle a dit \\\"Bonjour!\\\"\"\n  retour_ligne = \"Ligne 1\\nLigne 2\"\n  ```\nLes chaînes de caractères offrent une large gamme de techniques de traitement de texte et sont extrêmement polyvalentes. Les chaînes sont un outil essentiel que ce soit pour la manipulation de base ou les opérations complexes.\n\n  ```{.python}\n # Définition chaines de caractères\nchaine_simple = 'Bonjour'\nlongueur = len(chaine_simple) # 7\nprint(f\"{chaine_simple}, 'la longueur est {longueur}\")\n\nchaine_double = \"Python\"\nchaine_multiligne = \"\"\"Ceci est une\nchaîne sur plusieurs\nlignes.\"\"\"\nprint(chaine_double,\"\\n\", chaine_multiligne)\n\n# Acces aux éléments\npremier_char = chaine_simple[0]  # 'B'\nsous_chaine = chaine_double[1:4] # 'yth'\nprint(premier_char, \"et\",  sous_chaine)\n\n# Concaténation \nsalutation = chaine_simple + \", \" + chaine_double # 'Bonjour, Python'\nprint(salutation)\n\n# Répétition\necho = \"echo \" * 3  # 'echo echo echo '\nprint(echo)\n  ```\n\n## 5.1 Les méthodes \nLes méthodes pour les chaînes de caractères sont des fonctions liées à des objets particuliers. \nIls permettent d'agir sur ces objets ou de manipuler leurs données internes. \nVoici quelques aspects clés des méthodes :\n\n    Les méthodes sont liées à des objets, contrairement aux fonctions indépendantes. \n    Les méthodes de chaînes de caractères (\"str\"), par exemple, sont conçues pour effectuer des opérations sur des chaînes de caractères particulières.\n    La syntaxe est une technique qui utilise la notation pointée. Par exemple, utilisez \"objet.methode()\".\n    - Méthodes de chaînes de caractères : les fonctions \"upper()\", \"lower()\" et \"replace()\" peuvent être utilisées pour convertir les caractères en majuscules ou minuscules ou remplacer une partie de la chaîne.\n    - Appel : La syntaxe \"objet.methode(arguments)\" est généralement utilisée pour appeler une méthode.\n\n\n\n  ```{.python}\n# Méthodes str.isupper() et str.islower()\nmajuscules = \"PYTHON\"\nminuscules = \"python\"\nis_upper = majuscules.isupper()\nis_lower = minuscules.islower()\nprint(is_upper)  # Résultat : True\nprint(is_lower)  # Résultat : True\n\n# Méthode str.upper()\ntexte_upper = \"python est génial\".upper()\nprint(texte_upper)  # Résultat : \"PYTHON EST GÉNIAL\"\n\n# Méthode str.lower()\ntexte_lower = \"Python est GÉNIAL\".lower()\nprint(texte_lower)  # Résultat : \"python est génial\"\n\n# Méthode str.capitalize()\ntexte_capitalize = \"python est génial\".capitalize()\nprint(texte_capitalize)  # Résultat : \"Python est génial\"\n\n# Méthode str.title()\ntexte_title = \"python est génial\".title()\nprint(texte_title)  # Résultat : \"Python Est Génial\"\n\n# Méthode str.find(substring)\ntexte = \"Python est génial\"\nposition = texte.find(\"est\")\nprint(position)  # Résultat : 7\n\n# Méthode str.replace(old, new)\ntexte_replace = \"Les pommes sont rouges.\".replace(\"pommes\", \"bananes\")\nprint(texte_replace)  # Résultat : \"Les bananes sont rouges.\"\n\n# Méthode str.split(separator)\ntexte_split = \"apple,orange,banana\".split(\",\")\nprint(texte_split)  # Résultat : [\"apple\", \"orange\", \"banana\"]\n\n# Méthode str.join(iterable)\nelements = [\"apple\", \"orange\", \"banana\"]\ntexte_join = \", \".join(elements)\nprint(texte_join)  # Résultat : \"apple, orange, banana\"\n\n# Méthode str.strip()\ntexte_strip = \"   Bonjour   \".strip()\nprint(texte_strip)  # Résultat : \"Bonjour\"\n\n# Méthode str.startswith(prefix)\ntexte_startswith = \"Bonjour, comment ça va ?\".startswith(\"Bonjour\")\nprint(texte_startswith)  # Résultat : True\n\n# Méthode str.endswith(suffix)\ntexte_endswith = \"Leçon terminée.\".endswith(\"terminée.\")\nprint(texte_endswith)  # Résultat : TrueS\n  ```\n\n## 5.2 Les listes\n\nLes listes sont des structures de données qui peuvent contenir une série d'éléments. Elles sont flexibles, peuvent contenir divers types d'éléments et peuvent être modifiées.\n\nLes listes sont utilisées.\n  - Collections de valeurs organisées qui peuvent contenir divers types de données.\n  - Les virgules séparent les éléments et les crochets les entourent.\n  - Modifiables.\n  - Pour créer une liste, utilisez des virgules entre les crochets \"[]\" pour séparer une série d'éléments. Par exemple : « [1, \"a\", 3.14] ».\n  - Leur index commence par \"0\" pour accéder aux éléments.\n  - Parce que les listes sont mutables (modifiables), vous pouvez changer leurs éléments.\n\n```{.python}\n# Définition de liste\nma_liste = [1, 2, 3, \"Python\", 3.14]\nprint(ma_liste)\n\npremier_element = ma_liste[0]  # Accède au premier élément (1)\ndernier_element = ma_liste[-1] # Accède au dernier élément (3.14)\nprint(premier_element,\"\\n\", dernier_element)\n\n # Modifie le deuxième élément\nma_liste[1] = \"deux\" \nprint(ma_liste)\n\n# Concaténation et Répétition\ncombinee = ma_liste + [\"autre\", \"liste\"]\nrepetee = [1, 2, 3] * 3\n```\n\n### Les méthodes des listes \nChaque méthode offre une fonctionnalité unique pour manipuler des listes, rendant ces structures de données extrêmement flexibles et puissantes pour une variété de tâches en programmation Python.\n\n| Méthode        | Description                                              | Exemple d'Utilisation                   |\n|----------------|----------------------------------------------------------|----------------------------------------|\n| `append()`     | Ajoute un élément à la fin de la liste.                  | `liste.append(5)`                      |\n| `extend()`     | Étend la liste en ajoutant tous les éléments d'une autre liste. | `liste.extend([6, 7])`                |\n| `insert()`     | Insère un élément à une position donnée.                 | `liste.insert(1, 'a')`                 |\n| `remove()`     | Supprime la première occurrence d'un élément.            | `liste.remove('a')`                    |\n| `pop()`        | Supprime et renvoie un élément à une position donnée (par défaut, le dernier). | `liste.pop()`                          |\n| `clear()`      | Supprime tous les éléments de la liste.                  | `liste.clear()`                        |\n| `index()`      | Retourne l'indice du premier élément correspondant.      | `liste.index('a')`                     |\n| `count()`      | Compte le nombre d'occurrences d'un élément spécifique.  | `liste.count(5)`                       |\n| `sort()`       | Trie les éléments de la liste (dans un ordre spécifique). | `liste.sort()`                         |\n| `reverse()`    | Inverse l'ordre des éléments de la liste.                | `liste.reverse()`                      |\n| `copy()`       | Retourne une copie superficielle de la liste.            | `nouvelle_liste = liste.copy()`        |\n\n```{.python}\n# Création d'une liste de base\nma_liste = [1, 2, 3]\n\n# Utilisation de append()\nma_liste.append(4)\nprint(\"Après append(4):\", ma_liste)\n\n# Utilisation de extend()\nma_liste.extend([5, 6])\nprint(\"Après extend([5, 6]):\", ma_liste)\n\n# Utilisation de insert()\nma_liste.insert(1, 'a')\nprint(\"Après insert(1, 'a'):\", ma_liste)\n\n# Utilisation de remove()\nma_liste.remove('a')\nprint(\"Après remove('a'):\", ma_liste)\n\n# Utilisation de pop()\nelement_supprime = ma_liste.pop()\nprint(\"Après pop():\", ma_liste, \", Élément supprimé:\", element_supprime)\n\n# Utilisation de clear()\nma_liste.clear()\nprint(\"Après clear():\", ma_liste)\n\n# Recréation de la liste pour les autres méthodes\nma_liste = [3, 1, 4, 2, 2]\n\n# Utilisation de index()\nindex_de_4 = ma_liste.index(4)\nprint(\"Index de 4:\", index_de_4)\n\n# Utilisation de count()\ncompte_de_2 = ma_liste.count(2)\nprint(\"Nombre d'occurrences de 2:\", compte_de_2)\n\n# Utilisation de sort()\nma_liste.sort()\nprint(\"Après sort():\", ma_liste)\n\n# Utilisation de reverse()\nma_liste.reverse()\nprint(\"Après reverse():\", ma_liste)\n\n# Utilisation de copy()\ncopie_de_ma_liste = ma_liste.copy()\nprint(\"Copie de la liste:\", copie_de_ma_liste)\n```\n\n### Parcours de Liste\nLe parcours de liste permet d'accéder à chaque élément d'une liste de manière séquentielle. Cela peut être fait de différentes manières, mais les boucles \"for\" et \"while\" sont les plus courantes.\n\n    1. La boucle \"for\" est la méthode la plus fréquemment utilisée pour parcourir une liste. Elle permet de traiter chaque composant de manière indépendante.\n    2. La compréhension des listes est une méthode simple pour créer des listes. Elle permet de transformer une liste en une autre liste en filtrant les éléments pour former une liste des résultats d'une expression donnée.\n\nLa syntaxe fondamentale pour la compréhension de liste est :\n\n```{.python}\n[nouvelle_expression for item in iterable if condition]\n```\nL'expression \"nouvelle_expression\" définit comment organiser les éléments de l'iterable (comme une liste).\nLa variable qui prend la valeur de chaque élément de l'iterable à chaque itération est appelée \"item\".\nUne condition optionnelle pour filtrer les éléments de l'iterable est la \"condition\".\n\n```{.python}\n# récupérer tous les légumes avec un \"a\"\nlegumes = [\"carotte\", \"poivron\", \"haricot\"]\nnewlist = []\n\nfor l in legumes:\n  if \"a\" in l:\n    newlist.append(l)\n\nprint(newlist)\n```\n```{.python}\nnewlist = []\nnewlist = [l for l in legumes if \"l\" in l ]\nprint(newlist)\n```\n\n```{.python}\n# Créer une liste des carrés des nombres de 0 à 9 :\ncarres = [x**2 for x in range(10)]\n```\n\n```{.python}\n# Filtrer les nombres pairs dans une liste :\nnombres_pairs = [x for x in range(10) if x % 2 == 0]\n```\n\n```{.python}\n# Appliquer une fonction à tous les éléments :\nnoms_majuscules = [nom.upper() for nom in [\"alice\", \"bob\", \"charlie\"]]\n```\n\n## 5.3 Tuples (`tuple`) :\n  - Similaires aux listes, mais immuables (non modifiables après création).\n  - Les éléments sont séparés par des virgules et entourés de parenthèses.\n  - Exemple : `(1, \"a\", 3.14)`.\n\n| Avantage                            | Description                                                  |\n|-------------------------------------|--------------------------------------------------------------|\n| **Sécurité des Données**            | Parfait pour protéger les données contre les modifications.   |\n| **Performance**                     | Plus rapides à parcourir que les listes.                     |\n| **Utilisation en tant que Clés de Dictionnaire** | Peuvent être utilisés comme clés dans les dictionnaires, contrairement aux listes. |\n| **Retour de Plusieurs Valeurs de Fonction** | Utilisés pour retourner plusieurs valeurs depuis une fonction. |\n| **Stockage de Données Constantes**  | Idéaux pour stocker des données qui ne doivent pas être modifiées. |\n\n```{.python}\n# Définition d'un tuple\nmon_tuple = (1, \"a\", 3.14)\n\nun_autre_tuple = 2, \"b\", 4.28\n\n# Accès aux Éléments\npremier_element = mon_tuple[0]  # 1\n\n# Tuple à Un Élément\ntuple_singleton = (5,)\n\n# Imbrication\ntuple_imbrique = (1, (2, 3), (4, 5))\n\n# Méthodes Utiles\nlongueur = len(mon_tuple)  # Retourne la longueur de mon_tuple, ici 3\ncompteur = mon_tuple.count(1)  # Compte le nombre de fois que 1 apparaît dans mon_tuple, ici 1\nindice = mon_tuple.index(\"a\")  # Trouve l'indice de \"a\" dans mon_tuple, ici 1\n```\n\n## 5.4 Ensembles (`set`) :\n- Ensembles non structurés de valeurs uniques.\n  - Bénéfiques pour l'analyse globale et la recherche de valeurs spécifiques.\n  - Ils peuvent être modifiés, mais chaque élément doit être unique.\n  - Non-ordonnés : L'ordre des éléments n'est pas respecté dans les ensembles. Il n'est donc pas possible d'accéder aux éléments en utilisant un index.\n  - Illustration : `{1, 2, 3}`.\n\nOpérations d'Ensemble\n\n| Opération             | Syntaxe    | Description                                    |\n|-----------------------|------------|------------------------------------------------|\n| Union                 | `a \\| b`    | Retourne un nouvel ensemble contenant tous les éléments uniques des ensembles `a` et `b`. |\n| Intersection          | `a & b`    | Retourne un nouvel ensemble contenant uniquement les éléments communs aux ensembles `a` et `b`. |\n| Différence            | `a - b`    | Retourne un nouvel ensemble contenant les éléments de `a` qui ne sont pas dans `b`. |\n| Différence Symétrique | `a ^ b`    | Retourne un nouvel ensemble contenant tous les éléments qui sont dans `a` ou `b`, mais pas dans les deux. |\n| Ajout                 | `a.add(x)` | Ajoute l'élément `x` à l'ensemble `a`. |\n| Suppression           | `a.remove(x)` | Supprime l'élément `x` de l'ensemble `a` ; lève une erreur si `x` n'est pas présent. |\n| Suppression (sans erreur) | `a.discard(x)` | Supprime l'élément `x` de l'ensemble `a` si `x` est présent ; ne fait rien sinon. |\n\n```{.python}\n# Définition des ensembles\nensemble_a = {1, 2, 3, 4}\nensemble_b = {3, 4, 5, 6}\n\n# Opérations d'ensemble\nunion = ensemble_a | ensemble_b\nintersection = ensemble_a & ensemble_b\ndifference = ensemble_a - ensemble_b\ndifference_symetrique = ensemble_a ^ ensemble_b\n\n# Affichage des résultats\nprint(\"Union :\", union)\nprint(\"Intersection :\", intersection)\nprint(\"Différence :\", difference)\nprint(\"Différence Symétrique :\", difference_symetrique)\n\n# Ajout et suppression\nensemble_a.add(7)\nprint(\"Après ajout :\", ensemble_a)\nensemble_a.remove(1)\nprint(\"Après suppression :\", ensemble_a)\nensemble_a.discard(8)  # Ne fait rien car 8 n'est pas dans l'ensemble\n```\n\n## 5.5 Dictionnaires (`dict`) :\n\n- Fondés sur des paires essentielles.\n- Les valeurs peuvent être consultées grâce aux clés.\n- Transférables, offrant la possibilité de mettre à jour et de supprimer.\n\n- Exemple : `{\"nom\": \"Maroua\", \"âge\": 30}`.\n\n- Gestion d'informations organisées : Idéal pour conserver des données complexes telles que des données utilisateur.\n- Recherche rapide : Optez pour des dictionnaires afin de réaliser des recherches rapides en utilisant des clés spécifiques.\n\n```{.python}\n# Définition d'un dictionnaire\npersonne = {\"nom\": \"Maroua\", \"age\": 30}\nautre_dict = dict(nom=\"Mouloud\", age=25)\n\n# Ajout et Mise à Jour\npersonne[\"profession\"] = \"Referente pedagogique\"\n```\n\n```{.python}\n# Utilisation de keys()\ncles = personne.keys()\nprint(\"Clés:\", cles)\n\n# Utilisation de values()\nvaleurs = personne.values()\nprint(\"Valeurs:\", valeurs)\n\n# Utilisation de items()\npaires = personne.items()\nprint(\"Paires clé-valeur:\", paires)\n\n# Utilisation de get()\nnom = personne.get(\"nom\")  # Retourne 'Maroua'\nville = personne.get(\"ville\", \"Non spécifiée\")  # Retourne 'Non spécifiée' car 'ville' n'existe pas\nprint(\"Nom:\", nom)\nprint(\"Ville:\", ville)\n\n# Parcours des clés\nprint(\"\\nParcours des clés:\")\nfor cle in personne:\n    print(cle)\n\n# Parcours des valeurs\nprint(\"\\nParcours des valeurs:\")\nfor valeur in personne.values():\n    print(valeur)\n\n# Parcours des paires clé-valeur\nprint(\"\\nParcours des paires clé-valeur:\")\nfor cle, valeur in personne.items():\n    print(cle, \":\", valeur)\n\nprint(\"\\nParcours des paires clé-valeur avec enumerate:\")\nfor index, (cle, valeur) in enumerate(personne.items()):\n    print(f\"Index {index}: Clé = {cle}, Valeur = {valeur}\")\n```\n\n```{.python}\n# Suppression\ndel personne[\"age\"]\nprofession = personne.pop(\"profession\")\npersonne\n```\n\n# 6. Fonctions\n\nLorsqu’une tâche doit être réalisée plusieurs fois par un programme avec seulement des paramètres différents, on peut l’isoler au sein d’une fonction. Cette approche est également intéressante si la personne qui définit la fonction est différente de celle qui l’utilise. Par exemple, nous avons déjà utilisé la fonction print() qui avait été définie par quelqu’un d’autre.\nDéfinition d’une fonction - def\nSyntaxe\n\nLa syntaxe Python pour la définition d’une fonction est la suivante :\n\ndef nom_fonction(liste de paramètres):\n      bloc d'instructions\nVous pouvez choisir n’importe quel nom pour la fonction que vous créez, à l’exception des mots-clés réservés du langage, et à la condition de n’utiliser aucun caractère spécial ou accentué (le caractère souligné « _ » est permis). Comme c’est le cas pour les noms de variables, on utilise par convention des minuscules, notamment au début du nom (les noms commençant par une majuscule seront réservés aux classes).\n\nCorps de la fonction\n\nComme les instructions if, for et while, l’instruction def est une instruction composée. La ligne contenant cette instruction se termine obligatoirement par un deux-points :, qui introduisent un bloc d’instructions qui est précisé grâce à l’indentation. Ce bloc d’instructions constitue le corps de la fonction.\n\nFonction sans paramètre\nExemple\n\n```{.python}\ndef compteur3():\n    i = 0\n    while i < 3:\n        print(i)\n        i = i + 1\n\nprint(\"bonjour\")\ncompteur3()\ncompteur3()\n```\n\nEn entrant ces quelques lignes, nous avons défini une fonction très simple qui compte jusqu’à 2. Notez bien les parenthèses, les deux-points, et l’indentation du bloc d’instructions qui suit la ligne d’en-tête (c’est ce bloc d’instructions qui constitue le corps de la fonction proprement dite).\n\nAprès la définition de la fonction, on trouve le programme principal qui débute par l’instruction print(\"bonjour\"). Il y a ensuite au sein du programme principal, l’appel de la fonction grâce à compteur3().\n\nIl est également possible de sauvegarder ce programme en tant que script au sein d’IDLE. Après avoir exécuté ce script, pour utiliser à nouveau la fonction que nous venons de définir, il suffit de l’appeler par son nom au niveau du shell. \n\nNous pouvons maintenant réutiliser cette fonction à plusieurs reprises, autant de fois que nous le souhaitons.\n\nNous pouvons également l’incorporer dans la définition d’une autre fonction.\n\nExemple de fonction qui appelle une autre fonction\n\n```{.python}\ndef compteur3():\n    i = 0\n    while i < 3:\n        print(i)\n        i = i + 1\n\ndef double_compteur3():\n    compteur3()\n    compteur3()\n\nprint(\"bonjour\")\ndouble_compteur3()\n```\n\nUne première fonction peut donc appeler une deuxième fonction, qui elle-même en appelle une troisième, etc.\n\nCréer une nouvelle fonction offre l’opportunité de donner un nom à tout un ensemble d’instructions. De cette manière, on peut simplifier le corps principal d’un programme, en dissimulant un algorithme secondaire complexe sous une commande unique, à laquelle on peut donner un nom explicite.\n\nUne fonction est donc en quelque sorte une nouvelle instruction personnalisée, qu’il est possible d’ajouter librement à notre langage de programmation.\n\n","srcMarkdownNoYaml":"\nBienvenue dans ce cours introductif sur Python. \nCe cours couvrira les concepts de base pour vous permettre de démarrer avec Python.\n\n# 1. Introduction aux variables et types de Données\n\n## 1.1 Variables\n\nLes variables sont essentielles en programmation. Elles servent de conteneurs pour stocker des données, comme des nombres ou des textes. En Python, créer une variable est simple :\n\n\n```{.python}\nx = 10\n```\n\nIci, x est une variable contenant la valeur 10. Python est un langage à typage dynamique, ce qui signifie que vous n'avez pas besoin de déclarer le type de la variable explicitement.\n\n\nIci, x est une variable contenant la valeur 10. Python est un langage à typage dynamique, ce qui signifie que vous n'avez pas besoin de déclarer le type de la variable explicitement.\n\n\nAffectation : L'opérateur = est utilisé pour assigner une valeur à une variable.\n\n\nTypage dynamique : Python détermine le type de la variable lors de son exécution.\n\n\nRéaffectation : Les valeurs des variables peuvent être modifiées.\n\n\nSensibilité à la casse : a et A sont considérées comme deux variables distinctes.\n\n\nAstuce : Utilisez print(variable1, variable2) pour afficher plusieurs variables.\n\n\nConventions de Nommage\n\nLes conventions courantes incluent :\n\ncamelCase : maVariable\nPascalCase : MaVariable\nsnake_case : ma_variable\nÉvitez les noms de variables commençant par des chiffres, ou contenant des espaces ou des symboles spéciaux.\n\n## 1.2 Types de données\n\nPython offre une variété de types de données :\n\nEntiers (int) : Nombres sans décimales (5, -3).\n\nFlottants (float) : Nombres avec décimales (3.14).\n\nChaînes de caractères (str) : Textes (\"Bonjour\").\n\nBooléens (bool) : Valeurs True ou False.\n\n# 2. Conversion de types et opérations\n\n## 2.1 Convertir des types pour la programmation\nLe processus de conversion de type, également appelé \"casting\", permet de changer une valeur d'un type de données à un autre.\n\n\nLes fonctions intégrées de Python incluent les entiers (int), les chaînes de caractères (str), les booléens (bool) et les nombres à virgule flottante (float).\n\nObservons quelques exemples de conversion entre ces catégories :\n\n### Conversion d'une valeur en entier (`int`)\n\n```{.python}\n# Depuis une chaîne de caractères** :\nchaine = \"789\"\nnombre = int(chaine)  # Convertit la chaîne \"789\" en entier 789\n\n## Depuis un booléen** :\nvrai = True\nentier = int(vrai)  # Convertit True en 1\n\n## Depuis un float** :\nflottant = 7.36\nentier = int(flottant)  # Convertit 7.36 en 7 (troncature, pas d'arrondi)\n```\n### Conversion d'une valeur en Chaîne de Caractères (`str`)\n\n```{.python}\n## Depuis un entier ou un float** :\nnombre = 789\nchaine = str(nombre)  # Convertit l'entier 789 en chaîne \"789\"\n\n## Depuis un booléen** :\nvrai = True\nchaine = str(vrai)  # Convertit True en \"True\"\n```\n### Conversion d'une valeur en Booléen (`bool`)\n\n```{.python}\n## Depuis une chaîne de caractères** :\nchaine = \"\"\nbooleen = bool(chaine)  # Convertit une chaîne vide en False\nchaine2 = \"Python\"\nbooleen2 = bool(chaine2)  # Convertit \"Python\" en True\n\n## Depuis un nombre** : \nnombre = 0\nbooleen = bool(nombre)  # Convertit 0 en False\nnombre2 = 123\nbooleen2 = bool(nombre2)  # Convertit 123 en True\n```\n\n### Conversion d'une valeur en Float (`float`)\n\n```{.python}\n## Depuis une chaîne de caractères** :\nchaine = \"673.85\"\nflottant = float(chaine)  # Convertit la chaîne \"673.85\" en float 673.85\n\n## Depuis un entier** :\nentier = 500\nflottant = float(entier)  # Convertit l'entier 500 en float 500.0\n\n## Depuis un booléen** :\nvrai = True\nflottant = float(vrai)  # Convertit True en 1.0\n```\n\n### Affectation de valeurs différentes\n\n```{.python}\nx, y, z = \"Chocolat\", \"Spéculos\", \"Café\"\nprint(x)\nprint(y)\nprint(z)\n```\nAffectation de la même valeur\n\n```{.python}\nx = y = z = \"Café\"\nprint(x)\nprint(y)\nprint(z)\n```\n## 2.2 Opérations\n\n### Opérations arithmétiques\n\nArithmétique : Addition (+), soustraction (-), multiplication (*), et division (/).\n\n```{.python}\nsomme = 20 + 15      # Résultat: 35\ndifference = 20 - 5  # Résultat: 15\nproduit = 20 * 5     # Résultat: 100\nquotient = 40 / 5    # Résultat: 8.0\n```\n\nModulo (%) retourne le reste de la division \nPuissance (**) élève un nombre à une certaine puissance.\n\n```{.python}\nreste = 10 % 3       # Résultat: 1\npuissance = 2 ** 3   # Résultat: 8\n```\n### Opérations sur les chaînes \n\nLa concaténation (+) combine des chaînes\n\nLa répétition (*) répète une chaîne un certain nombre de fois.\n\n```{.python}\nmessage = \"Salut\" + \"bande de nazes\"  # Résultat: \"Salut bande de nazes\"\necho = \"Ho\" * 3                    # Résultat: \"HoHoHo\"\n```\n\n### Opérateurs d'affectation composés\n\nLes raccourcis appelés opérateurs d'affectation composés combinent une affectation et une opération arithmétique ou binaire.\n\nEn somme, ils vous permettent d'effectuer une opération sur une variable et de réaffecter le résultat en une seule étape.\n\n```{.python}\n# Initialisation de x\nx = 5\nprint(x)\n\n# Ajouter et assigner\nx += 2  # x est maintenant 7\nprint(x)\n\n# Soustraire et assigner\nx -= 3  # x est maintenant 4\nprint(x)\n\n# Multiplier et assigner\nx *= 4  # x est maintenant 16\nprint(x)\n\n# Diviser et assigner\nx /= 2  # x est maintenant 8\nprint(x)\n\n# Division entière et assigner\nx //= 3  # x est maintenant 2\nprint(x)\n\n# Modulo et assigner\nx %= 3  # x est maintenant 2\nprint(x)\n\n# Exponentielle et assigner\nx **= 2  # x est maintenant 4\nprint(x)\n```\n# 3. Commentaires et affichage\n\n## 3.1 Commentaires\n\nLe code est expliqué à l'aide de commentaires.\n\nIls sont extrêmement utiles pour ceux qui lisent votre code, ainsi que pour vous-même. Les commentaires commencent par un **#** et se poursuivent jusqu'à la fin de la ligne.\n\nLors de l'exécution du code, les commentaires sont ignorés.\n\n```{.python}\n# Ceci est un commentaire \n\nz = 69  # Ceci est un commentaire suivant une instruction\n\n# Vous pouvez utiliser les commentaires pour expliquer\n# ce que votre code est censé faire :\nz = x + 9  # Ajout de 9 à x et stockage du résultat dans z\n```\n\n## 3.2 Affichage\n\nLa fonction print() est utilisée pour l'affichage.\n\nElle permet d'afficher sur la console le texte, les nombres et d'autres objets.\n\n```{.python}\nprint(\"Salut, ça va ?\")  # Affiche un message simple\n\nnombre = 69\nprint(nombre)  # Affiche la valeur de la variable 'nombre'\n\n# Vous pouvez aussi combiner du texte et des variables :\nprint(\"Le nombre est\", nombre)  # Affiche \"Le nombre est 69\"\n```\n### Utilisation de f-string\n\n```{.python}\nprenom = 'Maroua'\nage = 30\ntaille = 155\n\n# Formatage de chaînes avec f-string pour une lisibilité améliorée :\nprint(f\"Le nombre est {nombre}\") \nprint(f\"{prenom}, est partie\")\n```\n### f-string avec Plusieurs Variables\n\n```{.python}\nprint(f\"{prenom} mesure {taille} metres et a {age} ans\")\n```\n\n### Utilisation de format\n\n```{.python}\nprint(\"{} a {} ans \".format(prenom, age))\n```\n\n- Les variables sont insérées dans la chaîne de caractères à l'aide de la méthode.format().\nLes espaces réservés appelés \"{}\" seront remplacés par les arguments de la fonction \".format()\" dans l'ordre.\nLe premier \"{}\" contient l'insertion de \"ma_chaine\" et de \"age\", respectivement.\n\n Calculer et mesurer\n\nLa valeur de \"prop\" est affichée dans le premier \"print(prop)\", avec tous ses chiffres après la virgule.\n- La seconde fonction \"print()\" utilise une string f avec un format spécifique appelé \"{prop:.2f}\". \n\nEn conséquence, la valeur \"prop\" affichera seulement deux chiffres après la virgule.\n\n```{.python}\nprop = (4500 + 2575) / 14800\nprint(prop)\nprint(f\"La proportion de GC est {prop:.2f}\")\n```\n# 4. Structures de contrôle\n\n## 4.1 Les opérateurs\n\nLes opérateurs Python sont utilisés pour effectuer des opérations sur les variables et les valeurs.\n\n**Les opérateurs de comparaison** incluent égal à, différent de, supérieur à, inférieur à, supérieur ou égal à, et inférieur ou égal à.\n\n| Opérateur comparaison | Description |\n| ----------- | ----------- |\n| Egalité | == |\n| Différent de |!= |\n| Supérieur | > |\n| Inférieur | < |\n| Supérieur ou égale | >= |\n| Inférieur ou égale | <= |\n\n\n - Renvoient soit Vrai, soit Faux, en fonction du résultat de la comparaison.\n\n**Les opérateurs logiques** et, ou et non sont souvent combinés avec les opérateurs de comparaison.\n\n| Opérateur logique| Description | Résultat |\n| ----------- | ----------- |----------- |\n| And | and | True si les deux propositions sont vraies|\n| Or |  or | True si au moins une des propositions est Vraie |\n| Not | not | inverse de l'instruction |\n\n\n**Les opérateurs d'appartenance** in et not in sont utilisés pour vérifier si une valeur ou une chaîne de caractères se trouve à l'intérieur d'une autre valeur, chaîne de caractères ou séquence.\n\n| Opérateur logique| Description | Résultat |\n| ----------- | ----------- |----------- |\n| In | in | True si la valeur spécifiée est présente dans l'objet.|\n| Not in | not in | True si la valeur spécifiée n'est pas présente dans l'objet.|\n\n\n```{.python}\n# Exemples d'opérateurs de comparaison\nprint(\"Opérateurs de comparaison:\")\nprint(5 == 5)  # Égalité, renvoie True\n\nprint(5 != 2)  # Différent de, renvoie True\nprint(5 > 3)   # Supérieur à, renvoie True\nprint(5 < 8)   # Inférieur à, renvoie True\nprint(5 >= 3)  # Supérieur ou égal à, renvoie True\nprint(5 <= 8)  # Inférieur ou égal à, renvoie True\n\n# Exemples d'opérateurs logiques\nprint(\"\\nOpérateurs logiques:\")\nprint(True and False)  # and, renvoie False\nprint(True or False)   # or, renvoie True\nprint(not True)        # not, renvoie False\n\n# Exemples d'opérateurs d'appartenance\nprint(\"\\nOpérateurs d'appartenance:\")\nliste = [1, 2, 3, 4, 5]\nprint(3 in liste)       # in, renvoie True\nprint(6 not in liste)   # not in, renvoie True\n```\n\n## 4.2 Conditions\n\n```{.python}\n# condition\nx = 100 \n\n# Première condition : vérifie si x est inférieur à 10\nif x < 10:\n    print(\"x est inférieur à 10\")\n# Deuxième condition : vérifie si x est supérieur ou égal à 100\nelif x >= 100:\n    print(\"x est supérieur ou égal à 100\")\n# Dernière condition : si toutes les conditions précédentes sont fausses\nelse:\n    print(\"x est supérieur à 10 mais inférieur à 100\")\n```\n\n\n```{.python}\n# Initialisation des variables\nx = 100 \ny = 30 \n\n# Première condition : vérifie si x est inférieur à 10 ET y est supérieur à 20\nif (x < 10) and (y > 20):\n    print(\"x est inférieur à 10 et y est supérieur à 20\")\n# Deuxième condition : vérifie si x est supérieur ou égal à 100 OU y est supérieur ou égal à 30\nelif x >= 100 or y >= 30:\n    print(\"x est supérieur ou égal à 100 ou y est supérieur ou égal à 30\")\n# Dernière condition : si toutes les conditions précédentes sont fausses\nelse:\n    print(\"x est supérieur à 10\")\n```\n## 4.3 Les boucles \n\n### Boucle for\n\nLa boucle for peut être utilisée pour parcourir différentes structures de données, telles qu'une liste, un tuple, un tableau, une chaîne de caractères ou un dictionnaire.\n\nLa boucle commence par examiner le premier élément de la séquence et effectuer des actions dans son corps avant de passer à l'élément suivant jusqu'à ce que la séquence soit terminée.\n\n Une boucle est composée d'un mot-clé appelé \"for\", d'une variable temporaire qui contient chaque élément, d'un mot-clé appelé \"in\" et de la séquence à parcourir, suivie de deux points. Jusqu'au bout de l'élément - Appliquer des opérations sur la variable temporaire du corps de la boucle pour effectuer diverses opérations.\n- Combiner des fors - La méthode \"items()\" permet de boucler les clés et les valeurs dans les dictionnaires.\n\n```{.python}\n# Exemple de boucle for\nfor i in range(5):\n    print(i)\n\nfruits = [\"pomme\", \"banane\", \"mangue\", \"cerise\"]\nfor fruit in fruits:\n    print(fruit)\n\nprint(\"Boucle for sur une liste:\")\nma_liste = [1, 2, 3, 4, 5]\nfor element in ma_liste:\n    print(element)\n\nnombres = [1, 2, 3, 4, 5]\nfor nombre in nombres:\n    if nombre % 2 == 0:\n        print(f\"{nombre} est pair\")\n    else:\n        print(f\"{nombre} est impair\")\n```\n\n### Boucle while\n\nTant qu'une condition est vraie, la boucle while itère sur un bloc de code.\nLes boucles \"while\" continuent l'itération tant que la condition reste vraie, contrairement aux boucles \"for\".\n\n- \"break\" pour interrompre une boucle \"while\" prématurément, même si la condition est toujours vraie.\nUne boucle \"while\" peut utiliser \"else\" pour indiquer un bloc de code qui s'exécutera lorsque la condition de la boucle ne sera plus vraie.\nIl est possible d'ignorer le code restant dans l'itération actuelle de la boucle en cliquant sur \"continue\" pour passer à l'itération suivante.\n- Afin d'éviter de créer des boucles infinies, utilisez \"continue\" avec précaution.\n\n```{.python}\n# Boucle while avec break\nprint(\"\\nBoucle while avec break:\")\ni = 1\nwhile i <= 5:\n    print(i)\n    if i == 3:\n        print(\"Break à 3\")\n        break\n    i += 1\n\n# Boucle while avec continue\nprint(\"\\nBoucle while avec continue:\")\ni = 0\nwhile i < 5:\n    i += 1\n    if i == 3:\n        continue\n    print(i)\n\n# Boucle while avec else\nprint(\"\\nBoucle while avec else:\")\ni = 1\nwhile i <= 5:\n    print(i)\n    i += 1\nelse:\n    print(\"La condition n'est plus vraie (i > 5)\")\n\n# Exemple de boucle while True\nprint(\"Boucle while True avec un mécanisme de sortie :\")\n\ncompteur = 0\nwhile True:\n    compteur += 1\n    print(compteur)\n\n    # Interrompre la boucle si compteur atteint 5\n    if compteur == 5:\n        print(\"Compteur a atteint 5, sortir de la boucle.\")\n        break\n```\n\n# 5. Structures séquentielles\n\nChaque structure séquentielle a ses propres caractéristiques et utilisations, offrant une grande flexibilité pour le traitement des données. Les dictionnaires et les listes sont très populaires pour leur flexibilité et leur capacité de stockage dynamique.\n\n\nLes chaînes de caractères (strings) sont utilisées pour stocker et modifier du texte. Le texte est entouré de guillemets simples (\"...\"), doubles (\"...\"\") ou triples (\"...\") pour les chaînes de plusieurs lignes.\n\n\n  - Séquences de caractères avec un index de 0.\n  Les limites peuvent être marquées par des guillemets simples, doubles ou triples.\n  - Par exemple, \"Python\" et \"Data\".\n  Caractères d'échappement : Utilisez des caractères d'échappement (\"\") pour inclure des caractères spéciaux, tels que des guillemets ou des retours à la ligne, dans une chaîne.\n\n  ```{.python}\n  python\n  citation = \"Elle a dit \\\"Bonjour!\\\"\"\n  retour_ligne = \"Ligne 1\\nLigne 2\"\n  ```\nLes chaînes de caractères offrent une large gamme de techniques de traitement de texte et sont extrêmement polyvalentes. Les chaînes sont un outil essentiel que ce soit pour la manipulation de base ou les opérations complexes.\n\n  ```{.python}\n # Définition chaines de caractères\nchaine_simple = 'Bonjour'\nlongueur = len(chaine_simple) # 7\nprint(f\"{chaine_simple}, 'la longueur est {longueur}\")\n\nchaine_double = \"Python\"\nchaine_multiligne = \"\"\"Ceci est une\nchaîne sur plusieurs\nlignes.\"\"\"\nprint(chaine_double,\"\\n\", chaine_multiligne)\n\n# Acces aux éléments\npremier_char = chaine_simple[0]  # 'B'\nsous_chaine = chaine_double[1:4] # 'yth'\nprint(premier_char, \"et\",  sous_chaine)\n\n# Concaténation \nsalutation = chaine_simple + \", \" + chaine_double # 'Bonjour, Python'\nprint(salutation)\n\n# Répétition\necho = \"echo \" * 3  # 'echo echo echo '\nprint(echo)\n  ```\n\n## 5.1 Les méthodes \nLes méthodes pour les chaînes de caractères sont des fonctions liées à des objets particuliers. \nIls permettent d'agir sur ces objets ou de manipuler leurs données internes. \nVoici quelques aspects clés des méthodes :\n\n    Les méthodes sont liées à des objets, contrairement aux fonctions indépendantes. \n    Les méthodes de chaînes de caractères (\"str\"), par exemple, sont conçues pour effectuer des opérations sur des chaînes de caractères particulières.\n    La syntaxe est une technique qui utilise la notation pointée. Par exemple, utilisez \"objet.methode()\".\n    - Méthodes de chaînes de caractères : les fonctions \"upper()\", \"lower()\" et \"replace()\" peuvent être utilisées pour convertir les caractères en majuscules ou minuscules ou remplacer une partie de la chaîne.\n    - Appel : La syntaxe \"objet.methode(arguments)\" est généralement utilisée pour appeler une méthode.\n\n\n\n  ```{.python}\n# Méthodes str.isupper() et str.islower()\nmajuscules = \"PYTHON\"\nminuscules = \"python\"\nis_upper = majuscules.isupper()\nis_lower = minuscules.islower()\nprint(is_upper)  # Résultat : True\nprint(is_lower)  # Résultat : True\n\n# Méthode str.upper()\ntexte_upper = \"python est génial\".upper()\nprint(texte_upper)  # Résultat : \"PYTHON EST GÉNIAL\"\n\n# Méthode str.lower()\ntexte_lower = \"Python est GÉNIAL\".lower()\nprint(texte_lower)  # Résultat : \"python est génial\"\n\n# Méthode str.capitalize()\ntexte_capitalize = \"python est génial\".capitalize()\nprint(texte_capitalize)  # Résultat : \"Python est génial\"\n\n# Méthode str.title()\ntexte_title = \"python est génial\".title()\nprint(texte_title)  # Résultat : \"Python Est Génial\"\n\n# Méthode str.find(substring)\ntexte = \"Python est génial\"\nposition = texte.find(\"est\")\nprint(position)  # Résultat : 7\n\n# Méthode str.replace(old, new)\ntexte_replace = \"Les pommes sont rouges.\".replace(\"pommes\", \"bananes\")\nprint(texte_replace)  # Résultat : \"Les bananes sont rouges.\"\n\n# Méthode str.split(separator)\ntexte_split = \"apple,orange,banana\".split(\",\")\nprint(texte_split)  # Résultat : [\"apple\", \"orange\", \"banana\"]\n\n# Méthode str.join(iterable)\nelements = [\"apple\", \"orange\", \"banana\"]\ntexte_join = \", \".join(elements)\nprint(texte_join)  # Résultat : \"apple, orange, banana\"\n\n# Méthode str.strip()\ntexte_strip = \"   Bonjour   \".strip()\nprint(texte_strip)  # Résultat : \"Bonjour\"\n\n# Méthode str.startswith(prefix)\ntexte_startswith = \"Bonjour, comment ça va ?\".startswith(\"Bonjour\")\nprint(texte_startswith)  # Résultat : True\n\n# Méthode str.endswith(suffix)\ntexte_endswith = \"Leçon terminée.\".endswith(\"terminée.\")\nprint(texte_endswith)  # Résultat : TrueS\n  ```\n\n## 5.2 Les listes\n\nLes listes sont des structures de données qui peuvent contenir une série d'éléments. Elles sont flexibles, peuvent contenir divers types d'éléments et peuvent être modifiées.\n\nLes listes sont utilisées.\n  - Collections de valeurs organisées qui peuvent contenir divers types de données.\n  - Les virgules séparent les éléments et les crochets les entourent.\n  - Modifiables.\n  - Pour créer une liste, utilisez des virgules entre les crochets \"[]\" pour séparer une série d'éléments. Par exemple : « [1, \"a\", 3.14] ».\n  - Leur index commence par \"0\" pour accéder aux éléments.\n  - Parce que les listes sont mutables (modifiables), vous pouvez changer leurs éléments.\n\n```{.python}\n# Définition de liste\nma_liste = [1, 2, 3, \"Python\", 3.14]\nprint(ma_liste)\n\npremier_element = ma_liste[0]  # Accède au premier élément (1)\ndernier_element = ma_liste[-1] # Accède au dernier élément (3.14)\nprint(premier_element,\"\\n\", dernier_element)\n\n # Modifie le deuxième élément\nma_liste[1] = \"deux\" \nprint(ma_liste)\n\n# Concaténation et Répétition\ncombinee = ma_liste + [\"autre\", \"liste\"]\nrepetee = [1, 2, 3] * 3\n```\n\n### Les méthodes des listes \nChaque méthode offre une fonctionnalité unique pour manipuler des listes, rendant ces structures de données extrêmement flexibles et puissantes pour une variété de tâches en programmation Python.\n\n| Méthode        | Description                                              | Exemple d'Utilisation                   |\n|----------------|----------------------------------------------------------|----------------------------------------|\n| `append()`     | Ajoute un élément à la fin de la liste.                  | `liste.append(5)`                      |\n| `extend()`     | Étend la liste en ajoutant tous les éléments d'une autre liste. | `liste.extend([6, 7])`                |\n| `insert()`     | Insère un élément à une position donnée.                 | `liste.insert(1, 'a')`                 |\n| `remove()`     | Supprime la première occurrence d'un élément.            | `liste.remove('a')`                    |\n| `pop()`        | Supprime et renvoie un élément à une position donnée (par défaut, le dernier). | `liste.pop()`                          |\n| `clear()`      | Supprime tous les éléments de la liste.                  | `liste.clear()`                        |\n| `index()`      | Retourne l'indice du premier élément correspondant.      | `liste.index('a')`                     |\n| `count()`      | Compte le nombre d'occurrences d'un élément spécifique.  | `liste.count(5)`                       |\n| `sort()`       | Trie les éléments de la liste (dans un ordre spécifique). | `liste.sort()`                         |\n| `reverse()`    | Inverse l'ordre des éléments de la liste.                | `liste.reverse()`                      |\n| `copy()`       | Retourne une copie superficielle de la liste.            | `nouvelle_liste = liste.copy()`        |\n\n```{.python}\n# Création d'une liste de base\nma_liste = [1, 2, 3]\n\n# Utilisation de append()\nma_liste.append(4)\nprint(\"Après append(4):\", ma_liste)\n\n# Utilisation de extend()\nma_liste.extend([5, 6])\nprint(\"Après extend([5, 6]):\", ma_liste)\n\n# Utilisation de insert()\nma_liste.insert(1, 'a')\nprint(\"Après insert(1, 'a'):\", ma_liste)\n\n# Utilisation de remove()\nma_liste.remove('a')\nprint(\"Après remove('a'):\", ma_liste)\n\n# Utilisation de pop()\nelement_supprime = ma_liste.pop()\nprint(\"Après pop():\", ma_liste, \", Élément supprimé:\", element_supprime)\n\n# Utilisation de clear()\nma_liste.clear()\nprint(\"Après clear():\", ma_liste)\n\n# Recréation de la liste pour les autres méthodes\nma_liste = [3, 1, 4, 2, 2]\n\n# Utilisation de index()\nindex_de_4 = ma_liste.index(4)\nprint(\"Index de 4:\", index_de_4)\n\n# Utilisation de count()\ncompte_de_2 = ma_liste.count(2)\nprint(\"Nombre d'occurrences de 2:\", compte_de_2)\n\n# Utilisation de sort()\nma_liste.sort()\nprint(\"Après sort():\", ma_liste)\n\n# Utilisation de reverse()\nma_liste.reverse()\nprint(\"Après reverse():\", ma_liste)\n\n# Utilisation de copy()\ncopie_de_ma_liste = ma_liste.copy()\nprint(\"Copie de la liste:\", copie_de_ma_liste)\n```\n\n### Parcours de Liste\nLe parcours de liste permet d'accéder à chaque élément d'une liste de manière séquentielle. Cela peut être fait de différentes manières, mais les boucles \"for\" et \"while\" sont les plus courantes.\n\n    1. La boucle \"for\" est la méthode la plus fréquemment utilisée pour parcourir une liste. Elle permet de traiter chaque composant de manière indépendante.\n    2. La compréhension des listes est une méthode simple pour créer des listes. Elle permet de transformer une liste en une autre liste en filtrant les éléments pour former une liste des résultats d'une expression donnée.\n\nLa syntaxe fondamentale pour la compréhension de liste est :\n\n```{.python}\n[nouvelle_expression for item in iterable if condition]\n```\nL'expression \"nouvelle_expression\" définit comment organiser les éléments de l'iterable (comme une liste).\nLa variable qui prend la valeur de chaque élément de l'iterable à chaque itération est appelée \"item\".\nUne condition optionnelle pour filtrer les éléments de l'iterable est la \"condition\".\n\n```{.python}\n# récupérer tous les légumes avec un \"a\"\nlegumes = [\"carotte\", \"poivron\", \"haricot\"]\nnewlist = []\n\nfor l in legumes:\n  if \"a\" in l:\n    newlist.append(l)\n\nprint(newlist)\n```\n```{.python}\nnewlist = []\nnewlist = [l for l in legumes if \"l\" in l ]\nprint(newlist)\n```\n\n```{.python}\n# Créer une liste des carrés des nombres de 0 à 9 :\ncarres = [x**2 for x in range(10)]\n```\n\n```{.python}\n# Filtrer les nombres pairs dans une liste :\nnombres_pairs = [x for x in range(10) if x % 2 == 0]\n```\n\n```{.python}\n# Appliquer une fonction à tous les éléments :\nnoms_majuscules = [nom.upper() for nom in [\"alice\", \"bob\", \"charlie\"]]\n```\n\n## 5.3 Tuples (`tuple`) :\n  - Similaires aux listes, mais immuables (non modifiables après création).\n  - Les éléments sont séparés par des virgules et entourés de parenthèses.\n  - Exemple : `(1, \"a\", 3.14)`.\n\n| Avantage                            | Description                                                  |\n|-------------------------------------|--------------------------------------------------------------|\n| **Sécurité des Données**            | Parfait pour protéger les données contre les modifications.   |\n| **Performance**                     | Plus rapides à parcourir que les listes.                     |\n| **Utilisation en tant que Clés de Dictionnaire** | Peuvent être utilisés comme clés dans les dictionnaires, contrairement aux listes. |\n| **Retour de Plusieurs Valeurs de Fonction** | Utilisés pour retourner plusieurs valeurs depuis une fonction. |\n| **Stockage de Données Constantes**  | Idéaux pour stocker des données qui ne doivent pas être modifiées. |\n\n```{.python}\n# Définition d'un tuple\nmon_tuple = (1, \"a\", 3.14)\n\nun_autre_tuple = 2, \"b\", 4.28\n\n# Accès aux Éléments\npremier_element = mon_tuple[0]  # 1\n\n# Tuple à Un Élément\ntuple_singleton = (5,)\n\n# Imbrication\ntuple_imbrique = (1, (2, 3), (4, 5))\n\n# Méthodes Utiles\nlongueur = len(mon_tuple)  # Retourne la longueur de mon_tuple, ici 3\ncompteur = mon_tuple.count(1)  # Compte le nombre de fois que 1 apparaît dans mon_tuple, ici 1\nindice = mon_tuple.index(\"a\")  # Trouve l'indice de \"a\" dans mon_tuple, ici 1\n```\n\n## 5.4 Ensembles (`set`) :\n- Ensembles non structurés de valeurs uniques.\n  - Bénéfiques pour l'analyse globale et la recherche de valeurs spécifiques.\n  - Ils peuvent être modifiés, mais chaque élément doit être unique.\n  - Non-ordonnés : L'ordre des éléments n'est pas respecté dans les ensembles. Il n'est donc pas possible d'accéder aux éléments en utilisant un index.\n  - Illustration : `{1, 2, 3}`.\n\nOpérations d'Ensemble\n\n| Opération             | Syntaxe    | Description                                    |\n|-----------------------|------------|------------------------------------------------|\n| Union                 | `a \\| b`    | Retourne un nouvel ensemble contenant tous les éléments uniques des ensembles `a` et `b`. |\n| Intersection          | `a & b`    | Retourne un nouvel ensemble contenant uniquement les éléments communs aux ensembles `a` et `b`. |\n| Différence            | `a - b`    | Retourne un nouvel ensemble contenant les éléments de `a` qui ne sont pas dans `b`. |\n| Différence Symétrique | `a ^ b`    | Retourne un nouvel ensemble contenant tous les éléments qui sont dans `a` ou `b`, mais pas dans les deux. |\n| Ajout                 | `a.add(x)` | Ajoute l'élément `x` à l'ensemble `a`. |\n| Suppression           | `a.remove(x)` | Supprime l'élément `x` de l'ensemble `a` ; lève une erreur si `x` n'est pas présent. |\n| Suppression (sans erreur) | `a.discard(x)` | Supprime l'élément `x` de l'ensemble `a` si `x` est présent ; ne fait rien sinon. |\n\n```{.python}\n# Définition des ensembles\nensemble_a = {1, 2, 3, 4}\nensemble_b = {3, 4, 5, 6}\n\n# Opérations d'ensemble\nunion = ensemble_a | ensemble_b\nintersection = ensemble_a & ensemble_b\ndifference = ensemble_a - ensemble_b\ndifference_symetrique = ensemble_a ^ ensemble_b\n\n# Affichage des résultats\nprint(\"Union :\", union)\nprint(\"Intersection :\", intersection)\nprint(\"Différence :\", difference)\nprint(\"Différence Symétrique :\", difference_symetrique)\n\n# Ajout et suppression\nensemble_a.add(7)\nprint(\"Après ajout :\", ensemble_a)\nensemble_a.remove(1)\nprint(\"Après suppression :\", ensemble_a)\nensemble_a.discard(8)  # Ne fait rien car 8 n'est pas dans l'ensemble\n```\n\n## 5.5 Dictionnaires (`dict`) :\n\n- Fondés sur des paires essentielles.\n- Les valeurs peuvent être consultées grâce aux clés.\n- Transférables, offrant la possibilité de mettre à jour et de supprimer.\n\n- Exemple : `{\"nom\": \"Maroua\", \"âge\": 30}`.\n\n- Gestion d'informations organisées : Idéal pour conserver des données complexes telles que des données utilisateur.\n- Recherche rapide : Optez pour des dictionnaires afin de réaliser des recherches rapides en utilisant des clés spécifiques.\n\n```{.python}\n# Définition d'un dictionnaire\npersonne = {\"nom\": \"Maroua\", \"age\": 30}\nautre_dict = dict(nom=\"Mouloud\", age=25)\n\n# Ajout et Mise à Jour\npersonne[\"profession\"] = \"Referente pedagogique\"\n```\n\n```{.python}\n# Utilisation de keys()\ncles = personne.keys()\nprint(\"Clés:\", cles)\n\n# Utilisation de values()\nvaleurs = personne.values()\nprint(\"Valeurs:\", valeurs)\n\n# Utilisation de items()\npaires = personne.items()\nprint(\"Paires clé-valeur:\", paires)\n\n# Utilisation de get()\nnom = personne.get(\"nom\")  # Retourne 'Maroua'\nville = personne.get(\"ville\", \"Non spécifiée\")  # Retourne 'Non spécifiée' car 'ville' n'existe pas\nprint(\"Nom:\", nom)\nprint(\"Ville:\", ville)\n\n# Parcours des clés\nprint(\"\\nParcours des clés:\")\nfor cle in personne:\n    print(cle)\n\n# Parcours des valeurs\nprint(\"\\nParcours des valeurs:\")\nfor valeur in personne.values():\n    print(valeur)\n\n# Parcours des paires clé-valeur\nprint(\"\\nParcours des paires clé-valeur:\")\nfor cle, valeur in personne.items():\n    print(cle, \":\", valeur)\n\nprint(\"\\nParcours des paires clé-valeur avec enumerate:\")\nfor index, (cle, valeur) in enumerate(personne.items()):\n    print(f\"Index {index}: Clé = {cle}, Valeur = {valeur}\")\n```\n\n```{.python}\n# Suppression\ndel personne[\"age\"]\nprofession = personne.pop(\"profession\")\npersonne\n```\n\n# 6. Fonctions\n\nLorsqu’une tâche doit être réalisée plusieurs fois par un programme avec seulement des paramètres différents, on peut l’isoler au sein d’une fonction. Cette approche est également intéressante si la personne qui définit la fonction est différente de celle qui l’utilise. Par exemple, nous avons déjà utilisé la fonction print() qui avait été définie par quelqu’un d’autre.\nDéfinition d’une fonction - def\nSyntaxe\n\nLa syntaxe Python pour la définition d’une fonction est la suivante :\n\ndef nom_fonction(liste de paramètres):\n      bloc d'instructions\nVous pouvez choisir n’importe quel nom pour la fonction que vous créez, à l’exception des mots-clés réservés du langage, et à la condition de n’utiliser aucun caractère spécial ou accentué (le caractère souligné « _ » est permis). Comme c’est le cas pour les noms de variables, on utilise par convention des minuscules, notamment au début du nom (les noms commençant par une majuscule seront réservés aux classes).\n\nCorps de la fonction\n\nComme les instructions if, for et while, l’instruction def est une instruction composée. La ligne contenant cette instruction se termine obligatoirement par un deux-points :, qui introduisent un bloc d’instructions qui est précisé grâce à l’indentation. Ce bloc d’instructions constitue le corps de la fonction.\n\nFonction sans paramètre\nExemple\n\n```{.python}\ndef compteur3():\n    i = 0\n    while i < 3:\n        print(i)\n        i = i + 1\n\nprint(\"bonjour\")\ncompteur3()\ncompteur3()\n```\n\nEn entrant ces quelques lignes, nous avons défini une fonction très simple qui compte jusqu’à 2. Notez bien les parenthèses, les deux-points, et l’indentation du bloc d’instructions qui suit la ligne d’en-tête (c’est ce bloc d’instructions qui constitue le corps de la fonction proprement dite).\n\nAprès la définition de la fonction, on trouve le programme principal qui débute par l’instruction print(\"bonjour\"). Il y a ensuite au sein du programme principal, l’appel de la fonction grâce à compteur3().\n\nIl est également possible de sauvegarder ce programme en tant que script au sein d’IDLE. Après avoir exécuté ce script, pour utiliser à nouveau la fonction que nous venons de définir, il suffit de l’appeler par son nom au niveau du shell. \n\nNous pouvons maintenant réutiliser cette fonction à plusieurs reprises, autant de fois que nous le souhaitons.\n\nNous pouvons également l’incorporer dans la définition d’une autre fonction.\n\nExemple de fonction qui appelle une autre fonction\n\n```{.python}\ndef compteur3():\n    i = 0\n    while i < 3:\n        print(i)\n        i = i + 1\n\ndef double_compteur3():\n    compteur3()\n    compteur3()\n\nprint(\"bonjour\")\ndouble_compteur3()\n```\n\nUne première fonction peut donc appeler une deuxième fonction, qui elle-même en appelle une troisième, etc.\n\nCréer une nouvelle fonction offre l’opportunité de donner un nom à tout un ensemble d’instructions. De cette manière, on peut simplifier le corps principal d’un programme, en dissimulant un algorithme secondaire complexe sous une commande unique, à laquelle on peut donner un nom explicite.\n\nUne fonction est donc en quelque sorte une nouvelle instruction personnalisée, qu’il est possible d’ajouter librement à notre langage de programmation.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"cours.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","theme":{"light":"cosmo","dark":"cyborg"},"title":"Les fondamentaux de Python"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}